---
import type { SiteContent } from "../data/content";
interface Props {
  hero: SiteContent["hero"];
}
const { hero } = Astro.props;
---

<section class="hero-s">
  <img
    src="hero-background-spray-effect.webp"
    alt={hero.imgAlt}
    class="hero-s__bg"
    loading="eager"
    decoding="async"
  />

  <div class="hero-s__content">
    <span class="hero-s__preheadline">{hero.preheadline}</span>
    <h1 class="hero-s__title">{hero.title}</h1>
    <p class="hero-s__subtitle" set:html={hero.subtitle} />
    <a href="#value" class="btn-gold hero-s__cta">{hero.cta}</a>
  </div>

  <img
    src="hero-background-spray-effect.webp"
    alt={hero.imgAlt}
    class="hero-s__product"
    loading="eager"
    decoding="async"
  />

  <img
    src="/roses.webp"
    alt=""
    class="hero-s__rose"
    loading="eager"
    aria-hidden="true"
  />

  <div class="hero-s__particles" aria-hidden="true"></div>

  <a href="#value" class="hero-s__scroll-hint" aria-label="Scroll down">
    <svg
      width="24"
      height="24"
      viewBox="0 0 24 24"
      fill="none"
      stroke="currentColor"
      stroke-width="1.5"
    >
      <path d="M12 5v14M5 12l7 7 7-7"></path>
    </svg>
  </a>
</section>

<style>
  .hero-s {
    min-height: 100svh;
    display: flex;
    align-items: center;
    justify-content: flex-start;
    position: relative;
    overflow: hidden;
    background: var(--color-bg-primary);
  }

  /* Parallax background spray – desktop only */
  .hero-s__bg {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    object-fit: cover;
    object-position: 10% bottom;
    z-index: 0;
    will-change: transform;
    transform: scale(1.05);
    transition: transform 0.15s ease-out;
    pointer-events: none;
  }

  /* Dark overlay for text readability on left side */
  .hero-s::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to right,
      rgba(8, 8, 8, 0.85) 0%,
      rgba(8, 8, 8, 0.6) 25%,
      rgba(8, 8, 8, 0.25) 45%,
      rgba(8, 8, 8, 0.05) 60%,
      transparent 75%
    );
    pointer-events: none;
    z-index: 1;
  }

  /* Top/bottom vignette */
  .hero-s::after {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(
      to bottom,
      rgba(8, 8, 8, 0.4) 0%,
      transparent 10%,
      transparent 90%,
      rgba(8, 8, 8, 0.4) 100%
    );
    pointer-events: none;
    z-index: 1;
  }

  .hero-s__content {
    position: relative;
    z-index: 2;
    max-width: 600px;
    padding: var(--space-lg);
    padding-left: 15%;
  }

  .hero-s__preheadline {
    display: inline-block;
    font-family: var(--font-body);
    font-size: 0.85rem;
    font-weight: 600;
    letter-spacing: 0.35em;
    text-transform: uppercase;
    background: linear-gradient(
      90deg,
      var(--color-gold-dark) 0%,
      var(--color-gold-light) 40%,
      var(--color-gold) 60%,
      var(--color-gold-dark) 100%
    );
    background-size: 200% auto;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    animation:
      fadeInUp 0.8s ease forwards,
      shimmer 3s ease-in-out infinite;
    animation-delay: 0.3s, 0s;
    opacity: 0;
    margin-bottom: 1.5rem;
  }

  .hero-s__title {
    font-size: clamp(2.2rem, 7vw, 4.5rem);
    color: var(--color-text-primary);
    margin-bottom: var(--space-md);
    text-shadow: 0 2px 30px rgba(0, 0, 0, 0.6);
    animation: fadeInUp 0.8s ease forwards;
    animation-delay: 0.5s;
    opacity: 0;
  }

  .hero-s__subtitle {
    font-size: clamp(0.95rem, 2.5vw, 1.35rem);
    color: var(--color-text-primary);
    margin-bottom: var(--space-lg);
    line-height: 1.7;
    text-shadow: 0 1px 8px rgba(0, 0, 0, 0.5);
    animation: fadeInUp 0.8s ease forwards;
    animation-delay: 0.7s;
    opacity: 0;
    max-width: 480px;
  }

  .hero-s__cta {
    animation: fadeInUp 0.8s ease forwards;
    animation-delay: 0.9s;
    opacity: 0;
    font-size: 1.1rem;
    padding: 1rem 3rem;
    box-shadow:
      0 8px 25px rgba(222, 189, 84, 0.3),
      0 4px 10px rgba(222, 189, 84, 0.15);
  }

  /* Product image – hidden on desktop (visible via background), shown on mobile/tablet */
  .hero-s__product {
    display: none;
  }

  /* ---- Rose decoration ---- */
  .hero-s__rose {
    position: absolute;
    right: -2%;
    bottom: 0;
    width: 30%;
    max-width: 420px;
    height: auto;
    z-index: 3;
    pointer-events: none;
    object-fit: contain;
    object-position: right bottom;
    filter: drop-shadow(0 4px 20px rgba(0, 0, 0, 0.4));
    will-change: transform;
    transition: transform 0.15s ease-out;
  }

  /* ---- Particles ---- */
  .hero-s__particles {
    position: absolute;
    inset: 0;
    z-index: 4;
    pointer-events: none;
    overflow: hidden;
  }

  :global(.hero-s__particle) {
    position: absolute;
    border-radius: 50%;
    background: radial-gradient(
      circle at center,
      var(--p-core) 0%,
      var(--p-mid) 20%,
      var(--p-edge) 60%,
      transparent 100%
    );
    animation: particleFloatS var(--p-dur, 18s) ease-in-out infinite;
    animation-delay: var(--p-delay, 0s);
    will-change: transform, opacity;
  }

  @keyframes particleFloatS {
    0% {
      transform: translate(0, 0) scale(1);
      opacity: var(--p-opacity, 0.5);
    }
    25% {
      transform: translate(var(--p-dx1, 20px), var(--p-dy1, -50px)) scale(1.3);
      opacity: calc(var(--p-opacity, 0.5) * 1.5);
    }
    50% {
      transform: translate(var(--p-dx2, -15px), var(--p-dy2, -100px)) scale(0.7);
      opacity: var(--p-opacity, 0.5);
    }
    75% {
      transform: translate(var(--p-dx3, 10px), var(--p-dy3, -40px)) scale(1.2);
      opacity: calc(var(--p-opacity, 0.5) * 0.8);
    }
    100% {
      transform: translate(0, 0) scale(1);
      opacity: var(--p-opacity, 0.5);
    }
  }

  .hero-s__scroll-hint {
    position: absolute;
    bottom: var(--space-lg);
    left: 15%;
    color: var(--color-gold);
    z-index: 3;
    animation: fadeInUp 0.8s ease forwards;
    animation-delay: 1.2s;
    opacity: 0;
    cursor: pointer;
    transition:
      color var(--transition-fast),
      transform var(--transition-fast);
  }

  .hero-s__scroll-hint:hover {
    color: var(--color-gold-light);
    transform: translateY(4px);
  }

  .hero-s__scroll-hint svg {
    animation: floatS 2s ease-in-out infinite;
  }

  @keyframes floatS {
    0%,
    100% {
      transform: translateY(0);
    }
    50% {
      transform: translateY(8px);
    }
  }

  /* Mobile – hide rose & bg, show product */
  @media (max-width: 768px) {
    .hero-s__rose {
      display: none;
    }

    .hero-s__bg {
      display: none;
    }
  }

  /* Mobile – fullscreen, text centered, product bottom */
  @media (max-width: 768px) {
    .hero-s {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      background: var(--color-bg-primary);
      min-height: 100svh;
      position: relative;
    }

    .hero-s::before {
      display: none;
    }

    .hero-s::after {
      display: block;
      background: linear-gradient(
        to bottom,
        var(--color-bg-primary) 0%,
        var(--color-bg-primary) 45%,
        transparent 65%
      );
      z-index: 2;
    }

    .hero-s__content {
      padding: var(--space-lg);
      padding-left: var(--space-lg);
      max-width: 100%;
      width: 100%;
      z-index: 3;
      margin-bottom: 40%;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .hero-s__subtitle {
      margin-left: auto;
      margin-right: auto;
    }

    .hero-s__product {
      display: block;
      position: absolute;
      bottom: 0;
      right: -15%;
      width: auto;
      height: 55%;
      max-width: none;
      padding: 0;
      object-fit: contain;
      object-position: right bottom;
      z-index: 1;
    }

    .hero-s__scroll-hint {
      position: absolute;
      bottom: var(--space-lg);
      left: 50%;
      transform: translateX(-50%);
      margin: 0;
    }

    .hero-s__scroll-hint:hover {
      transform: translateX(-50%) translateY(4px);
    }
  }

  /* Larger phones / small tablets – remove negative right offset */
  @media (min-width: 700px) and (max-width: 768px) {
    .hero-s__product {
      right: 0;
    }
  }

  /* Tablet portrait (769px – 1023px) – rose smaller */
  @media (min-width: 769px) and (max-width: 1023px) {
    .hero-s__rose {
      width: 25%;
      right: -1%;
    }
  }

  /* Tablet portrait (769px – 1023px) – centered text, product bottom */
  @media (min-width: 769px) and (max-width: 1023px) {
    .hero-s {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      background: var(--color-bg-primary);
      min-height: 100svh;
      position: relative;
    }

    .hero-s__bg {
      display: none;
    }

    .hero-s::before {
      display: none;
    }

    .hero-s::after {
      display: none;
    }

    .hero-s__content {
      padding: var(--space-lg);
      padding-left: var(--space-lg);
      max-width: 100%;
      width: 100%;
      z-index: 2;
      margin-bottom: 35%;
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .hero-s__subtitle {
      margin-left: auto;
      margin-right: auto;
    }

    .hero-s__product {
      display: block;
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 100%;
      height: auto;
      max-width: none;
      object-fit: contain;
      object-position: center bottom;
    }

    .hero-s__scroll-hint {
      position: absolute;
      bottom: var(--space-lg);
      left: 50%;
      transform: translateX(-50%);
    }

    .hero-s__scroll-hint:hover {
      transform: translateX(-50%) translateY(4px);
    }
  }

  /* Large desktop – more breathing room */
  @media (min-width: 1200px) {
    .hero-s__content {
      padding-left: 25%;
      max-width: 60vw;
    }

    .hero-s__preheadline {
      font-size: 1rem;
    }

    .hero-s__cta {
      font-size: 1.2rem;
      padding: 1.2rem 3.5rem;
    }
  }
</style>

<script>
  const prefersReducedMotion = window.matchMedia(
    "(prefers-reduced-motion: reduce)",
  ).matches;

  const isMobile = window.matchMedia("(max-width: 768px)").matches;
  const isTablet = window.matchMedia("(min-width: 769px) and (max-width: 1023px)").matches;

  if (!prefersReducedMotion) {
    const container = document.querySelector(
      ".hero-s__particles",
    ) as HTMLElement;

    // Gradient palette matching spray – warm orange/amber core, gold mid, fading edge
    const COLORS = [
      { core: [255, 180, 60],  mid: [230, 130, 30],  edge: [180, 80, 10] },   // deep orange
      { core: [255, 160, 40],  mid: [220, 110, 20],  edge: [160, 70, 10] },   // warm amber
      { core: [255, 200, 80],  mid: [240, 160, 40],  edge: [200, 120, 20] },  // golden orange
      { core: [255, 140, 30],  mid: [200, 90, 15],   edge: [150, 60, 5] },    // hot orange
      { core: [255, 220, 120], mid: [222, 170, 60],  edge: [180, 120, 30] },  // bright gold
      { core: [240, 120, 20],  mid: [180, 80, 10],   edge: [120, 50, 5] },    // burnt orange
      { core: [255, 240, 180], mid: [255, 200, 80],  edge: [220, 160, 40] },  // light sparkle
      { core: [255, 100, 20],  mid: [200, 60, 10],   edge: [140, 40, 5] },    // red-orange ember
    ];

    interface Particle {
      el: HTMLElement;
      homeX: number; // home position in px
      homeY: number;
      offsetX: number; // current repulsion offset
      offsetY: number;
    }

    const particles: Particle[] = [];
    const REPEL_RADIUS = 150; // px – how far the "magnet" reaches
    const REPEL_STRENGTH = 80; // px – max push distance
    const EASE_BACK = 0.08; // how fast particles return (0-1)

    let mouseXpx = -9999; // mouse position in px relative to container
    let mouseYpx = -9999;
    let isMouseInHero = false;

    if (container) {
      const COUNT = isMobile ? 100 : isTablet ? 300 : 800;

      const hero = document.querySelector(".hero-s") as HTMLElement;
      const bgImg = document.querySelector(".hero-s__bg") as HTMLElement;
      const productImg = document.querySelector(".hero-s__product") as HTMLElement;

      // Nozzle position within the spray IMAGE (% of the image itself)
      const IMG_NOZZLE_X = 0.62;
      const IMG_NOZZLE_Y = 0.33;

      // Get the visible spray image bounds relative to hero
      function getImageBounds() {
        const heroRect = hero.getBoundingClientRect();
        // Desktop: __bg covers hero. Mobile/tablet: __product is visible
        const useDesktop = bgImg && getComputedStyle(bgImg).display !== "none";
        const img = useDesktop ? bgImg : productImg;
        if (!img || getComputedStyle(img).display === "none") {
          return { left: 0, top: 0, width: heroRect.width, height: heroRect.height };
        }
        const imgRect = img.getBoundingClientRect();
        return {
          left: imgRect.left - heroRect.left,
          top: imgRect.top - heroRect.top,
          width: imgRect.width,
          height: imgRect.height,
        };
      }

      function sprayPosition(): [number, number] {
        const bounds = getImageBounds();
        const heroW = hero.clientWidth;
        const heroH = hero.clientHeight;

        // Nozzle position in hero %
        const nozzleXpct = ((bounds.left + bounds.width * IMG_NOZZLE_X) / heroW) * 100;
        const nozzleYpct = ((bounds.top + bounds.height * IMG_NOZZLE_Y) / heroH) * 100;

        // Image bounding box in hero %
        const imgTopPct = (bounds.top / heroH) * 100;
        const imgBottomPct = ((bounds.top + bounds.height) / heroH) * 100;
        const imgLeftPct = (bounds.left / heroW) * 100;
        const imgRightPct = ((bounds.left + bounds.width) / heroW) * 100;

        // Max spray reach proportional to image size
        const reachMax = (bounds.width / heroW) * 55;

        // Floor reflection particles along the bottom of the image
        if (Math.random() < 0.15) {
          const floorY = imgBottomPct - (imgBottomPct - imgTopPct) * 0.15;
          return [
            imgLeftPct + Math.random() * (imgRightPct - imgLeftPct),
            floorY + Math.random() * (imgBottomPct - floorY),
          ];
        }

        // Generate spray cone position, reject if outside image bounds
        for (let attempt = 0; attempt < 10; attempt++) {
          const dist = Math.random();
          const baseAngle = (200 * Math.PI) / 180;
          const spread = 0.6 * dist + 0.15;
          const angle = baseAngle + (Math.random() - 0.5) * spread * Math.PI;
          const reach = dist * reachMax;

          const x = nozzleXpct + Math.cos(angle) * reach;
          const y = nozzleYpct + Math.sin(angle) * reach * 0.9;

          // Only keep particles that fall within the image area
          if (x >= imgLeftPct && x <= imgRightPct && y >= imgTopPct && y <= imgBottomPct) {
            return [x, y];
          }
        }

        // Fallback: place within image area near nozzle
        return [
          nozzleXpct + (Math.random() - 0.5) * 10,
          nozzleYpct + (Math.random() - 0.5) * 10,
        ];
      }

      for (let i = 0; i < COUNT; i++) {
        const dot = document.createElement("div");
        dot.className = "hero-s__particle";

        const [xPct, yPct] = sprayPosition();
        const size = 4 + Math.random() * 12;
        const opacity = 0.3 + Math.random() * 0.7;
        const duration = 12 + Math.random() * 14;
        const delay = -(Math.random() * duration);

        const dx1 = (Math.random() - 0.5) * 70;
        const dy1 = -20 - Math.random() * 70;
        const dx2 = (Math.random() - 0.5) * 50;
        const dy2 = -50 - Math.random() * 80;
        const dx3 = (Math.random() - 0.5) * 60;
        const dy3 = -15 - Math.random() * 50;

        const c = COLORS[Math.floor(Math.random() * COLORS.length)];
        const core = `rgba(${c.core.join(",")}, ${opacity})`;
        const mid = `rgba(${c.mid.join(",")}, ${opacity * 0.3})`;
        const edge = `rgba(${c.edge.join(",")}, ${opacity * 0.05})`;

        dot.style.cssText = `
          width:${size}px;height:${size}px;
          left:${xPct}%;top:${yPct}%;
          --p-core:${core};
          --p-mid:${mid};
          --p-edge:${edge};
          --p-opacity:${opacity};--p-dur:${duration}s;--p-delay:${delay}s;
          --p-dx1:${dx1}px;--p-dy1:${dy1}px;
          --p-dx2:${dx2}px;--p-dy2:${dy2}px;
          --p-dx3:${dx3}px;--p-dy3:${dy3}px;
        `;

        container.appendChild(dot);
        particles.push({
          el: dot,
          homeX: 0, // will be computed on first frame
          homeY: 0,
          offsetX: 0,
          offsetY: 0,
        });
      }

      // Compute home positions once layout is ready
      requestAnimationFrame(() => {
        const rect = container.getBoundingClientRect();
        for (const p of particles) {
          const r = p.el.getBoundingClientRect();
          p.homeX = r.left - rect.left + r.width / 2;
          p.homeY = r.top - rect.top + r.height / 2;
        }
      });
    }

    /* ---- Animation loop for repulsion physics ---- */
    const heroEl = document.querySelector(".hero-s") as HTMLElement;
    const bg = document.querySelector(".hero-s__bg") as HTMLElement;
    const rose = document.querySelector(".hero-s__rose") as HTMLElement;

    const STRENGTH_BG = 20;
    const STRENGTH_ROSE = 12;
    let mouseNormX = 0; // -0.5 to 0.5 for parallax
    let mouseNormY = 0;

    function tick() {
      // Parallax for bg & rose
      if (bg) {
        const bgX = mouseNormX * STRENGTH_BG;
        const bgY = mouseNormY * STRENGTH_BG;
        bg.style.transform = `translate(${bgX}px, ${bgY}px) scale(1.05)`;
      }
      if (rose) {
        const roseX = mouseNormX * STRENGTH_ROSE * -1;
        const roseY = mouseNormY * STRENGTH_ROSE * -1;
        rose.style.transform = `translate(${roseX}px, ${roseY}px)`;
      }

      // Repulsion physics for particles
      for (const p of particles) {
        if (isMouseInHero) {
          const dx = p.homeX + p.offsetX - mouseXpx;
          const dy = p.homeY + p.offsetY - mouseYpx;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < REPEL_RADIUS && dist > 0) {
            const force = (1 - dist / REPEL_RADIUS) * REPEL_STRENGTH;
            const angle = Math.atan2(dy, dx);
            const targetX = Math.cos(angle) * force;
            const targetY = Math.sin(angle) * force;
            p.offsetX += (targetX - p.offsetX) * 0.15;
            p.offsetY += (targetY - p.offsetY) * 0.15;
          } else {
            // Ease back to home
            p.offsetX *= 1 - EASE_BACK;
            p.offsetY *= 1 - EASE_BACK;
          }
        } else {
          // Mouse left — ease everything back
          p.offsetX *= 1 - EASE_BACK;
          p.offsetY *= 1 - EASE_BACK;
        }

        // Snap to zero when close enough
        if (Math.abs(p.offsetX) < 0.1 && Math.abs(p.offsetY) < 0.1) {
          p.offsetX = 0;
          p.offsetY = 0;
          p.el.style.translate = "";
        } else {
          p.el.style.translate = `${p.offsetX}px ${p.offsetY}px`;
        }
      }

      requestAnimationFrame(tick);
    }

    if (heroEl) {
      heroEl.addEventListener("mousemove", (e: MouseEvent) => {
        isMouseInHero = true;
        const rect = heroEl.getBoundingClientRect();
        mouseXpx = e.clientX - rect.left;
        mouseYpx = e.clientY - rect.top;
        mouseNormX = mouseXpx / rect.width - 0.5;
        mouseNormY = mouseYpx / rect.height - 0.5;
      });

      heroEl.addEventListener("mouseleave", () => {
        isMouseInHero = false;
        mouseNormX = 0;
        mouseNormY = 0;
      });

      requestAnimationFrame(tick);
    }
  }
</script>
